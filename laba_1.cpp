#include <iostream>
#include <locale.h>
#include <stdio.h>
#define  _CRT_SECURE_NO_WARNINGS

// Прототипы функций
void task_13(); // сумма цифр числа
void task_14(); // наибольшая цифра числа
void task_15(); // переворот числа
void task_16(); // перенос числа по цифрам в массив
void task_17(); // вывод чисел от 10 до 29999 включительно, которые равны суммам всех своих цифр в кубе
void task_18(); // поиск зеркальных чисел (только положительные числа)
void task_19(); // удаление отрицательных чисел из массива
void task_20(); // удаление максимального элемента из массива
void task_21(); // поиск простых чисел №1 
void task_22(); // поиск простых чисел №2 (цикл с переменной-признаком)
void task_23(); // поиск простых чисел №3 (поиск по массиву, запись найденных в другой массив)
void task_24(); // поиск простых чисел №4 (поиск по массиву, запись найденных в другой массив; цикл с переменной-признаком)
void task_25(); // удаление простых чисел из массива №1
void task_26(); // удаление простых чисел из массива №2 (цикл с переменной-признаком)
void task_27(); // поиск простых делителей числа
void task_28(); // поиск наибольшего общего делителя для чисел из массива (через цикл do .. while)
void task_29(); // поиск наибольшего общего делителя для чисел из массива (через цикл for)
void task_30(); // запись простых чисел и запись их в массив
void task_31(); // поиск одинаковых чисел в массиве
void task_32(); // поиск повторяющихся элементов в массиве, считаем их и выводим самое часто встречающееся число с его кол-вом повторов
void task_33(); // подсчёт максимальной цепочки из одинаковых рядом стоящих элементов
void task_34(); // какая степень двойки влезет
void task_35(); // разворот массива
void task_36(); // поиск числа "по середине" в массиве; если рассортировать массив, то это число будет ровно по середине массива
void task_37(); // попарное количество рядом стоящих одинаковых чисел
void task_38(); // максимальная цепочка из числа
void task_39(); // сумма положительных элементов в массиве до первого 0
void task_40(); // сумма положительных элементов в массиве до первого неположительного числа
void task_41(); // сумма положительных чисел до первого отрицательного числа включительно
void task_42(); // поиск середины массива по сумме элементов массива
void task_43(); // подсчёт суммы чётных и разности нечётных элементов массива
void task_44(); // сортировка чисел в порядке возрастания и запись их в другой массив
void task_45(); // сортировка чисел в порядке возрастания и запись их в другой массив (другой цикл)
void task_46(); // сортировка массива в порядке убывания
void task_47(); // числа, цифры которых делят это же число без остатка 
void task_48(); // удаление цепочек из одинаковых элементов
void task_49(); // поиск наименьшего положительного числа в массиве
void task_50(); // поиск пар элементов, где первое число отрицательно, а второе положительное
void task_51(); // поиск самого большого числа в массиве (переменная-максимум)
void task_52(); // поиск самого большого числа в массиве (поиск элемента)
void task_53(); // поиск номера наименьшего положительного числа в массиве №1
void task_54(); // поиск номера наименьшего положительного числа в массиве №2 (через ||)
void task_55(); // счёт колличества положительных чисел
void task_56(); // поиск пар отрицательное-положительное в массиве
void task_57(); // поиск самой длинной возрастающей цепочки
void task_58(); // АБСОЛЮТНО ТОЖЕ ЗАДАНИЕ, ЧТО И №50
void task_manager();

int main() // Запускать здесь 
{
	setlocale(LC_ALL, "Rus"); // кодировка с поддержкой кириллицы

	task_manager();
}

void task_manager() {
		int a;
		bool invl = false;

		do {
			if (invl) {
				system("cls");
				printf("Такого задания не существует!\n");
			}
			printf("Введите номер задания(от 13 до 58): ");
			scanf_s("%d", &a);
			printf("%d", a);
			if (13 > a || a > 58)
				invl = true;
			else {
				system("cls");
				printf("---Задание № %d---\n", a);
				break;
			}
		} while (invl);

		switch (a) {
		case 13: task_13();
			break;
		case 14: task_14();
			break;
		case 15: task_15();
			break;
		case 16: task_16();
			break;
		case 17: task_17();
			break;
		case 18: task_18();
			break;
		case 19: task_19();
			break;
		case 20: task_20();
			break;
		case 21: task_21();
			break;
		case 22: task_22();
			break;
		case 23: task_23();
			break;
		case 24: task_24();
			break;
		case 25: task_25();
			break;
		case 26: task_26();
			break;
		case 27: task_27();
			break;
		case 28: task_28();
			break;
		case 29: task_29();
			break;
		case 30: task_30();
			break;
		case 31: task_31();
			break;
		case 32: task_32();
			break;
		case 33: task_33();
			break;
		case 34: task_34();
			break;
		case 35: task_35();
			break;
		case 36: task_36();
			break;
		case 37: task_37();
			break;
		case 38: task_38();
			break;
		case 39: task_39();
			break;
		case 40: task_40();
			break;
		case 41: task_41();
			break;
		case 42: task_42();
			break;
		case 43: task_43();
			break;
		case 44: task_44();
			break;
		case 45: task_45();
			break;
		case 46: task_46();
			break;
		case 47: task_47();
			break;
		case 48: task_48();
			break;
		case 49: task_49();
			break;
		case 50: task_50();
			break;
		case 51: task_51();
			break;
		case 52: task_52();
			break;
		case 53: task_53();
			break;
		case 54: task_54();
			break;
		case 55: task_55();
			break;
		case 56: task_56();
			break;
		case 57: task_57();
			break;
		case 58: task_58();
			break;
		}
}

//--------------------------------------------------------13
void task_13() { // сумма цифр числа
	int n, a, s, k;
	printf("Введите число: ");
	scanf_s("%d", &a);
	a = abs(a); // Модуль числа, избавляемся от минуса
	//-
	for (n = a, s = 0; n != 0; n = n / 10) // перебор каждой цифры в числе a
	{
		k = n % 10; // берём цифру с конца числа n
		s = s + k;  // s - сумма всех цифр числа; переменная-накопитель
	}
	//-
	printf("Сумма числа: %d ", s);
}

//--------------------------------------------------------14
void task_14() { // наибольшая цифра числа
	int n, a, s, k;
	printf("Введите число: ");
	scanf_s("%d", &a);
	a = abs(a); // Модуль числа, избавляемся от минуса
	//-
	for (n = a, s = 0; n != 0; n = n / 10) // перебор каждой цифры в числе a
	{
		k = n % 10; // берём цифру с конца числа n
		if (k > s) s = k; // s присваивается наибольшая цифра числа; переменная-максимум
	}
	//-
	printf("Наибольшая цифра числа: %d ", s);
}

//--------------------------------------------------------15
void task_15() { // переворот числа
	int n, a, s, k;
	printf("Введите число: ");
	scanf_s("%d", &a);
	//-
	for (n = a, s = 0; n != 0; n = n / 10) // перебор каждой цифры в числе a
	{
		k = n % 10; // берём цифру с конца числа n
		s = s * 10 + k; // в первый раз берём k для s потом приписываем 0 к s (сдвиг влево) и снова добавляем k; в конце получаем число наоборот; переменная-накопитель
	}
	//-
	printf("Число наоборот: %d ", s);
}

//--------------------------------------------------------16
void task_16() { // перенос числа по цифрам в массив
	int i, n, a, A[101]; // Т.к. массив статический и в него будут вписываться цифры числа a, определим размер массив с запасом, т.к. неизвестно какова будет длина a
	printf("Введите число (до 100 цифр в числе): ");
	scanf_s("%d", &a);
	a = abs(a); // Модуль числа, избавляемся от минуса
	//-
	for (i = 0, n = a; n != 0; i++, n = n / 10); // Подсчёт цифр в числе a; i - переменная-счётчик
	for (A[i--] = -1, n = a; n != 0; i--, n = n / 10) // записывает в массив цифры числа a, в конце ставит -1
		A[i] = n % 10;
	//-
	printf("Число расписанное в массиве: ");
	for (i = 0; A[i] != -1; i++) // выводим массив до -1
		printf("%d ", A[i]);
}

//--------------------------------------------------------17
void task_17() { // вывод чисел от 10 до 29999 включительно, которые равны суммам всех своих цифр в кубе
	int j, a, n, s, A[101], k; // ситуация таже, заранее неизвестно какой размер массива требуется, берём с запасом
	//-
	for (j = 0, a = 10; a < 30000; a++) { // перебор a от 10 до 29999 включительно
		for (n = a, s = 0; n != 0; n = n / 10) // перебор каждой цифры в числе a
		{
			k = n % 10; // берём цифру с конца числа n
			s = s + k; // сумма цифр числа n; s - переменная-накопитель
		}
		if (a == s * s * s) A[j++] = a; // если изначальное число а (от 10 до 29999) равно сумме всех его цифр в кубе, то происходит запись числа a в массив
	}
	//-
	for (j = 0; A[j] > 0; j++) // выводим массив, нужные элементы будут > 0, т.к. число a >= 10 
		printf("%d ", A[j]);
}

//--------------------------------------------------------18
void task_18() { // поиск зеркальных чисел (только положительные числа)
	int j, a, v, n, s, k, A[10000]; // ситуация таже, заранее неизвестно какой размер массива требуется, берём с запасом
	printf("Введите число (от 11 до 9.000.000): ");
	scanf_s("%d", &v);
	//-
	for (j = 0, a = 10; a < v; a++) { // перебор a от 10 до v-1 включительно
		for (n = a, s = 0; n != 0; n = n / 10) // перебор каждой цифры в числе a
		{
			k = n % 10; // берём цифру с конца числа n
			s = s * 10 + k; // в первый раз берём k для s потом приписываем 0 к s (сдвиг влево) и снова добавляем k; в конце получаем число наоборот; s - переменная-накопитель
		}
		if (a == s) A[j++] = a; // если изначальное число а (от 10 до v-1) равно его записи с конца (зеркальное число), то происходит запись числа a в массив

	}
	//-
	printf("Зеркальные числа: ");
	for (j = 0; A[j] > 0; j++) // выводим массив, нужные элементы будут > 0, т.к. число a >= 10 
		printf("%d ", A[j]);
}

//--------------------------------------------------------19
void task_19() { // удаление отрицательных чисел из массива
	int i, A[] = { 10, -21, -3, -6, 9, -12, -3, -2, -19, 43 }, j;
	int n = sizeof(A) / sizeof(int); // автоматически подсчитываем кол-во элементов в массиве по формуле (размер массива в байтах)/(размер int переменной в байтах)
	//-
	for (i = 0; i < n; i++) { // удаляем все отрицательные числа в массиве
		if (A[i] < 0) { // если элемент массива отрицателен
			for (j = i; j < n - 1; j++) A[j] = A[j + 1]; // заменяем элемент массива на элемент справа, таким образом отрицательное число заменяется числом справа от него и происходит сдвиг элементов влево
			n--; // после сдвига элементов уменьшаем кол-во проходов на 1, тем самым указываем кол-во положительных элементов в массиве (положительные элементы сдвигаются влево)
			i--; // обязательно снова проверям тот же порядковый элемент который может быть отрицательным после сдвига
		}
	}
	//-
	for (j = 0; j < n; j++) // выводим массив; выводим по n, т.к. в n указано сколько первых элементов в массиве неотрицательны
		printf("%d ", A[j]);
}

//--------------------------------------------------------20
void task_20() { // удаление максимального элемента из массива
	int i, k, A[] = { 1, 2343, 544, 6, 53245, 43, 213 }, j;
	int n = sizeof(A) / sizeof(int); // автоматически подсчитываем кол-во элементов в массиве по формуле (размер массива в байтах)/(размер int переменной в байтах)
	//-
	for (i = 1, k = 0; i < n; i++)
		if (A[i] > A[k]) k = i; // находим номер максимального элемента в массиве; k - переменная-максимум
	for (j = k; j < n - 1; j++) A[j] = A[j + 1]; // сдвигаем массив влево перезаписывая при этом максимальный элемент в массиве
	n--; // кол-во элементов в массиве теперь на 1 меньше
	//-
	for (j = 0; j < n; j++) // выводим массив по кол-ву элементов n
		printf("%d ", A[j]);
}

//--------------------------------------------------------21
void task_21() { // поиск простых чисел №1
	int i, a, v, n, A[10000]; // ситуация таже, заранее неизвестно какой размер массива требуется, берём с запасом
	printf("Введите число (от 2): ");
	scanf_s("%d", &v);
	//-
	for (i = 0, a = 2; a < v; a++) { // простые числа начинаются с 2, a - число
		for (n = 2; n < a; n++) // проверяем в цикле от 2 до самого числа его делители, n - играет роль делителя числа
		{
			if (a % n == 0) break; // остаток от деления 0 означает, что существует делитель n для а
		}
		if (n == a) A[i++] = a; // если число равно делителю, то значит брейк на предыдущем шаге произошёл при делении числа самого на себя, следовательно до этого момента ни одного делителя для этого числа не было найдено и значит это число простое
	}
	A[i] = 0; // конец массива
	//-
	printf("Простые числа от 2 до %d: ", v);
	for (i = 0; A[i] > 0; i++) // выводим массив; все простые числа - натуральные (> 0)
		printf("%d ", A[i]);
}

//--------------------------------------------------------22
void task_22() { // поиск простых чисел №2 (цикл с переменной-признаком)
	int i, a, s, v, n, A[10000]; // ситуация таже, заранее неизвестно какой размер массива требуется, берём с запасом
	printf("Введите число (от 2): ");
	scanf_s("%d", &v);
	//-
	for (i = 0, a = 2; a < v; a++) { // простые числа начинаются с 2, a - число
		for (s = 0, n = 2; n < a; n++) // проверяем в цикле от 2 до самого числа его делители, n - играет роль делителя числа, s - переменная-проверка наличия делителя
			if (a % n == 0) {
				s = 1; // есть делитель, брейкаемся; s - переменная-признак
				break;
			}
		if (s == 0) A[i++] = a; // s = 0 значит делителя нет, число простое
	}
	A[i] = 0;
	//-
	printf("Простые числа от 2 до %d: ", v);
	for (i = 0; A[i] > 0; i++) // выводим массив; все простые числа - натуральные (> 0)
		printf("%d ", A[i]);
}

//--------------------------------------------------------23
void task_23() { // поиск простых чисел №3 (поиск по массиву, запись найденных в другой массив)
	int j, i, m, A[] = { 123, 645, 11, 97, 113, 917 }, B[100];
	int n = sizeof(A) / sizeof(int); // автоматически подсчитываем кол-во элементов в массиве по формуле (размер массива в байтах)/(размер int переменной в байтах)
	//-
	for (j = 0, i = 0; i < n; i++) { // перебираем элементы массива
		for (m = 2; m < A[i]; m++) // перебираем делители m от 2 до числа A[i] не включительно
		{
			if (A[i] % m == 0) break; // нашли делитель, число непростое, брейк
		}
		if (m == A[i]) B[j++] = A[i]; // нашли простое число, добавляем его в массив B
	}
	B[j] = 0;
	//-
	printf("Простые числа из массива: ");
	for (i = 0; B[i] > 0; i++) // выводим массив; все простые числа - натуральные (> 0)
		printf("%d ", B[i]);
}

//--------------------------------------------------------24
void task_24() { // поиск простых чисел №4 (поиск по массиву, запись найденных в другой массив; цикл с переменной-признаком)
	int j, i, s, m, A[] = { 123, 645, 11, 97, 113, 917 }, B[100];
	int n = sizeof(A) / sizeof(int); // автоматически подсчитываем кол-во элементов в массиве по формуле (размер массива в байтах)/(размер int переменной в байтах)
	//-
	for (j = 0, i = 0; i < n; i++) { // перебираем элементы массива
		for (s = 0, m = 2; m < A[i]; m++) // перебираем делители m от 2 до числа A[i] не включительно, используем переменную-защёлку для определения наличия делителя
			if (A[i] % m == 0) {
				s = 1; // найден делитель, число непростое, брейкаемся; s - переменная-признак
				break;
			}
		if (s == 0) B[j++] = A[i]; // если переменная-защёлка не сработала, то значит число просток, переписываем его в другой массив
	}
	B[j] = 0;
	//-
	printf("Простые числа из массива: ");
	for (i = 0; B[i] > 0; i++) // выводим массив; все простые числа - натуральные (> 0)
		printf("%d ", B[i]);
}

//--------------------------------------------------------25
void task_25() { // удаление простых чисел из массива №1
	int i, m, A[] = { 123, 645, 11, 97, 113, 917 }, j;
	int n = sizeof(A) / sizeof(int); // автоматически подсчитываем кол-во элементов в массиве по формуле (размер массива в байтах)/(размер int переменной в байтах)
	//-
	for (i = 0; i < n; i++) { // перебираем элементы массива
		for (m = 2; m < A[i]; m++) // поиск делителей, проверка на простоту числа
		{
			if (A[i] % m == 0) break; // нашли делитель - сразу выходим
		}
		if (m == A[i]) { // если A[i] - простое число, то
			for (j = i; j < n - 1; j++) A[j] = A[j + 1]; // перезаписываем простое число в массиве числом справа от него, так проходимся до конца массива, чем делаем сдвиг с перезапись простого числа
			n--; // после сдвига элементов уменьшаем кол-во проходов на 1, тем самым указываем кол-во непростых чисел в массиве (непростые числа сдвигаются влево)
			i--; // обязательно снова проверям тот же порядковый элемент который может быть непростым после сдвига

		}
	}
	//-
	printf("Непростые числа из массива: ");
	for (j = 0; j < n; j++) // выводим массив по кол-ву элементов n
		printf("%d ", A[j]);
}

//--------------------------------------------------------26
void task_26() { // удаление простых чисел из массива №2 (цикл с переменной-признаком)
	int j, i, s, m, A[] = { 123, 645, 11, 97, 113, 917 };
	int n = sizeof(A) / sizeof(int); // автоматически подсчитываем кол-во элементов в массиве по формуле (размер массива в байтах)/(размер int переменной в байтах)
	//-
	for (j = 0, i = 0; i < n; i++) { // перебираем элементы массива
		for (s = 0, m = 2; m < A[i]; m++) // поиск делителей, проверка на простоту числа, исключаем делимость самого на себя
			if (A[i] % m == 0) {
				s = 1; // нашли делитель числа - срабатывает s - переменная-признак
				break;
			}
		if (s == 0) { // если число простое, то
			for (j = i; j < n - 1; j++) A[j] = A[j + 1]; // перезаписываем простое число в массиве числом справа от него, так проходимся до конца массива, чем делаем сдвиг с перезапись простого числа
			n--; // после сдвига элементов уменьшаем кол-во проходов на 1, тем самым указываем кол-во непростых чисел в массиве (непростые числа сдвигаются влево)
			i--; // обязательно снова проверям тот же порядковый элемент который может быть непростым после сдвига
		}
	}
	//-
	printf("Непростые числа из массива: ");
	for (j = 0; j < n; j++) // выводим массив по кол-ву элементов n
		printf("%d ", A[j]);
}

//--------------------------------------------------------27
void task_27() { // поиск простых делителей числа
	int i, val, m, A[100];
	int n = sizeof(A) / sizeof(int); // автоматически подсчитываем кол-во элементов в массиве по формуле (размер массива в байтах)/(размер int переменной в байтах)
	printf("Введите число: ");
	scanf_s("%d", &val);
	val = abs(val); // Модуль числа, избавляемся от минуса
	//-
	for (i = 0; i < n - 1 && val != 1; i++) { // ищем простые делители числа пока не кончится массив куда записываем делители или до последнего простого делителя числа
		for (m = 2; val % m != 0; m++); // перебор делителей числа до первого простого
		val /= m; // val = простой делитель; может быть равен 1 если мы дошли до просто числа
		A[i] = m; // записываем простой делитель числа
	}
	A[i] = 0; // обозначен конец массива
	//-
	printf("Простые делители числа: ");
	for (i = 0; A[i] != 0; i++) // выводим массив до конца делителей 
		printf("%d ", A[i]);
}

//--------------------------------------------------------28
void task_28() { // поиск наибольшего общего делителя для чисел из массива (через цикл do .. while)
	int v, A[] = { 20, 90, 920, 620, 1000, 910 }, i, s; // берём массив из чисел, делящихся на 10 и 5 (чтобы показать, что получаем наибольший общий делитель)
	int n = sizeof(A) / sizeof(int); // автоматически подсчитываем кол-во элементов в массиве по формуле (размер массива в байтах)/(размер int переменной в байтах)
	//-
	v = A[0] + 1; // берём первое число из массива и прибавляем 1 (особенности цикла do .. while)
	do {
		v--; // уменьшаем число на 1, теперь это делитель
		for (i = 0, s = 0; i < n; i++) // перебираем все элементы массива
			if (A[i] % v != 0) {  // если v - не делитель хотя для какого-нибудь числа, то 
				s = 1; // переменная-признак, продолжаем поиск делителя, выходим из цикла чтобы взять следующий делитель
				break;
			}
	} while (s == 1); // выйдем из цикла сразу только тогда когда число v будет делителем для всех чисел массива
	//-
	printf("Наибольший общий делитель для чисел из массива: %d", v); // v - наибольший общий делитель, т.к. мы вышли из поиска делителя сразу же после его нахождения
}

//--------------------------------------------------------29
void task_29() { // поиск наибольшего общего делителя для чисел из массива (через цикл for)
	int i, A[] = { 20, 90, 920, 620, 1000, 910 }, v = A[0]; // v - вручную задаём первый делитель
	int n = sizeof(A) / sizeof(int); // автоматически подсчитываем кол-во элементов в массиве по формуле (размер массива в байтах)/(размер int переменной в байтах)
	//-
	for (i = 0; i < n; i++) // перебираем элементы массива
		if (A[i] % v != 0) { // если элемент массива не делется нацело на делитель, то 
			v--; // уменьшаем делитель (перебор до первого общего)
			i = -1; // снова проверяем тот же элемент массива, но с новым делителем
		}
	//-
	printf("Наибольший общий делитель для чисел из массива: %d", v);
}

//--------------------------------------------------------30
void task_30() { // запись простых чисел и запись их в массив
	int i, a, m, s, j, A[1000], v;
	m = sizeof(A) / sizeof(int);
	printf("До какого числа ищем простые числа:");
	scanf_s("%d", &v);
	//-
	for (i = 0, a = 2; a < v && i < m - 1; a++) { // перебираем числа от 2 до v и до конца массива
		for (s = 0, j = 0; j < i; j++)
			if (a % A[j] == 0) { // если число непростое (не имеет делителей), то пропускаем его
				s = 1; // переменая-признак
				break;
			}
		if (s == 0) A[i++] = a;
	}
	A[i] = 0;
	//-
	for (i = 0; A[i] != 0; i++) // выводим массив
		printf("%d ", A[i]);
}

//--------------------------------------------------------31
int task_31a();

void task_31() { // поиск одинаковых чисел в массиве
	if (task_31a() != -1)
		printf("Номер повторяющегося элемента в массиве: %d", task_31a());
	else
		printf("Повторяющихся элементов в массиве нет");
}

int task_31a() {
	int i, j, c[] = { 2, 8, 3, 0, 5, 9, 4, 1, 2 };
	int n = sizeof(c) / sizeof(int); // размер массива
	//-
	for (i = 0; i < n - 1; i++)
		for (j = i + 1; j < n; j++) // перебираем пары элементов в массиве c[i] слева и c[j] справа
			if (c[i] == c[j]) return i; // возращаем номер первого повторяющегося элемента в массиве
	return -1; // возращаем -1 если нет таких чисел
	//-
}

//--------------------------------------------------------32
void task_32() { // поиск повторяющихся элементов в массиве, считаем их и выводим самое часто встречающееся число с его кол-вом повторов
	int s, i, k, j, c[] = { 1, 67, 3, 78, 5, 1, 1, 1, 1 }, b;
	int n = sizeof(c) / sizeof(int);
	//-
	for (s = 0, i = 0; i < n; i++) { // первый цикл по элементам
		for (k = 0, j = 0; j < n; j++) // второй цикл по элементам
			if (c[i] == c[j]) k++; // если какие-то элементы будут равны (проверяем даже одинаковые элементы чтобы указать что существует одно число); k - переменная-счётчик
		if (k > s) s = k, b = i; // находим максимальное кол-во повторившихся ( (k > s) s = k ) и записывание номер этого элемента ( b = i ), получаем пару номер элемента и его повторений в массиве; s - переменная-максимум
	}
	//-
	printf("Число: %d, его кол-во в массиве: %d", c[b], s);
}

//--------------------------------------------------------33
void task_33() { // подсчёт максимальной цепочки из одинаковых рядом стоящих элементов
	int s, i, A[] = { 1, 67, 3, 78, 5, 1, 1, 1, 1, 5, 5, 5, 5, 5 }, k, b;
	int n = sizeof(A) / sizeof(int);
	//-
	for (s = 0, i = 0; i < n - 1; i++) // перебор по массиву
		if (A[i] == A[i + 1]) { // если соседние элементы массива равны, то
			for (k = 2; i + k < n && A[i] == A[i + k]; k++); // смотрим на следующие элементы справа, смотрим пока элементы теже (считаем цепочку из одинаковых рядом стоящих элементов); до конца массива, пока не попадётся отличное число; k - переменная-счётчик
			if (k > s) s = k, b = i; // подсчёт цепочки закончен, смотрим, записываем только максимальную длину цепочки и сам элемент цепочки; s - переменная-максимум
		}
	//-
	printf("Число: %d, максимальная цепочка: %d", A[b], s);
}

//--------------------------------------------------------34
int task_34a(int(n));

void task_34() { // какая степень двойки влезет
	int n;
	printf("Введите число: ");
	scanf_s("%d", &n);
	printf("Максимальная степень двойки: %d", task_34a(n));
}

int task_34a(int(n)) {
	int k, m;
	//-
	for (k = 0, m = 1; m <= n; k++, m = m * 2); // считаем степени двойки до наибольшей, которая влезет в заданное число; m - переменная-накопитель
	return k - 1;
	//-
}

//--------------------------------------------------------35
void task_35() { // разворот массива
	int i, j, k, c[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
	int n = sizeof(c) / sizeof(int);
	//-
	for (i = 0, j = n - 1; i < j; i++, j--) // запускаем цикл с двумя индексами элементов массива, начинающиеся с разных концов массива
	{
		k = c[i]; c[i] = c[j]; c[j] = k; // обмен элементами, "переворот" массива
	}
	//-
	printf("Массив наоборот: ");
	for (i = 0; i < n; i++)
		printf("%d ", c[i]);
}

//--------------------------------------------------------36
int task_36a();

void task_36() { // поиск числа "по середине" в массиве; если рассортировать массив, то это число будет ровно по середине массива

	printf("Номер числа по середине массива: %d", task_36a()); // передаём массив и его размер, получаем номер элемента, выводим это значение из массива
}

int task_36a() {
	int i, j, k1, k2, c[] = { 20, 90, 920, 620, 1000, 910, 12, 62, 321 }; // любый массив с нечётным кол-вом элементов
	int n = sizeof(c) / sizeof(int);
	//-
	for (i = 0; i < n; i++) { // цикл по первому элементу
		for (j = k1 = k2 = 0; j < n; j++) // цикл по второму элементу
			if (c[i] != c[j]) // если они не равны, то
			{
				if (c[i] < c[j]) k1++; else k2++; // считаем сколько чисел больше нашего и сколько меньше; k1 и k2 - переменные-счётчики
			}
		if (k1 == k2) return i; // если кол-во чисел, которые меньше нашего равны тому кол-ву, которые больше нашего, то наше число - среднее
	}
	return -1;
	//-
}

//--------------------------------------------------------37
void task_37() { // попарное количество рядом стоящих одинаковых чисел
	int s, i, j, m, c[] = { 123, 64, 64, 64, 765, 234, 0 }, b;
	int n = sizeof(c) / sizeof(int);
	//-
	for (s = 0, i = 0; i < n - 1; i++) { // перебор по элементам массива
		for (j = i + 1, m = 0; j < n; j++) // второй перебор по элементам массива, начиная справа от первого
			if (c[i] == c[j]) m++; // если соседние элементы равны, то m++; m - переменная-счётчик
		if (m > s) s = m, b = i; // s - переменная-максимум
	}
	//-
	printf("Число: %d, кол-во пар: %d", c[b], s);
}

//--------------------------------------------------------38
void task_38() { // максимальная цепочка из числа
	int i, k, m, c[] = { 4, 5, 5, 5, 5, 5, 5, 46, 1, 9, 3, 65 }, b;
	int n = sizeof(c) / sizeof(int);
	//-
	for (i = k = m = 0; i < n - 1; i++)
		if (c[i] == c[i + 1]) k++; // если два соседних одинаковые, то считаем k
		else {
			if (k > m) m = k, b = i - k - 1; // m - переменная-максимум, максимальная длина цепочки, b - номер элемента
			k = 0; // сброс длины цепочки
		}
	//-
	printf("Максимальная цепочка из числа %d, продолжительность: %d", c[b + 1], m + 1);
}

//--------------------------------------------------------39
void task_39() { // сумма положительных элементов в массиве до первого 0
	int s, i, A[] = { -1000, 20, 90, 920, 620, 1000, 910 };
	int n = sizeof(A) / sizeof(int);
	//-
	for (s = 0, i = 0; i < n; i++) { // перебор элементов
		if (A[i] < 0) continue; // если элемент меньше 0, то пропускаем это число
		if (A[i] == 0) break; // если 0 то выходим из цикла
		s = s + A[i]; // сумма положительных элементов массива; s - переменная-накопитель
	}
	//-
	printf("Сумма положительных элементов: %d", s);
}

//--------------------------------------------------------40
void task_40() { // сумма положительных элементов в массиве до первого неположительного числа
	int s, i, A[] = { 20, 90, 920, 620, 1000, 910 };
	int n = sizeof(A) / sizeof(int);
	//-
	for (s = 0, i = 0; i < n && A[i] > 0; i++) // цикл пока не достигнем конца массива или не встретим неположительное число
		s = s + A[i]; // сумма положительных элементов; s - переменная-накопитель
	//-
	printf("Сумма положительных элементов: %d", s);
}

//--------------------------------------------------------41
void task_41() { // сумма положительных чисел до первого отрицательного числа включительно
	int k, s, i, A[] = { 20, 90, 920, 620, -1, 1000, 910 };
	int n = sizeof(A) / sizeof(int);
	//-
	for (k = 0, s = 0, i = 0; i < n && k == 0; i++) {
		if (A[i] < 0) k = 1; // k - переменная-защёлка
		s = s + A[i]; // сумма положительных элементов ;s - переменная-накопитель
	}
	//-
	printf("Сумма положительных элементов: %d", s);
}

//--------------------------------------------------------42
int task_42a();

void task_42() { // поиск середины массива по сумме элементов массива
	printf("Номер элемента (середины сумм элементов массива): %d", task_42a());
}

int task_42a() {
	int s1, s2, i, j, A[] = { 3, 4, 65, 723, 53, 132, 45, 858 };
	int n = sizeof(A) / sizeof(int);
	//-
	for (s1 = 0, s2 = 0, i = 0, j = n - 1; i <= j;) {
		if (s1 < s2) s1 += A[i], i++; // сумма слевого края массива; s1 - переменная-накопитель
		else s2 += A[j], j--; // сумма справого края массива; s2 - переменная-накопитель
	}
	return i;
	//-
}

//--------------------------------------------------------43
void task_43() { // подсчёт суммы чётных и разности нечётных элементов массива
	int s, i, A[] = { 6, 4, 76, 34, 56, 30, 44 }; // 6 + 76 + 56 + 44 - 4 - 34 - 30 = 114
	int n = sizeof(A) / sizeof(int);
	//-
	for (s = 0, i = 0; i < n; i++) {
		if (i % 2 == 0) s = s + A[i]; // сумма чётных элементов массива; s - переменная-накопитель
		else s = s - A[i]; // разность нечётных элементов массива
	}
	//-
	printf("%d", s); // s - это сумма чётных элементов и разность нечётных
}

//--------------------------------------------------------44
void task_44() { // сортировка чисел в порядке возрастания и запись их в другой массив
	int j, k, i, n, A[] = { 6, 4, 76, 34, 56, 30, 44 }, B[sizeof(A) / sizeof(int)];
	int n1 = n = sizeof(A) / sizeof(int);
	//-
	for (j = 0; n != 0; j++) {
		for (k = 0, i = 1; i < n; i++)
			if (A[i] < A[k]) k = i; // наименьший элемент в массиве A
		B[j] = A[k]; // записываем наименьший в B
		for (; k < n - 1; k++) A[k] = A[k + 1]; // затираем наименьший элемент со сдвигом влево
		n--; // массив был уменьшен через сдвиг, так что уменьшаем кол-во элементов
	}
	//-
	for (i = 0; i < n1; i++)
		printf("%d ", B[i]);
}

//--------------------------------------------------------45
void task_45() { // сортировка чисел в порядке возрастания и запись их в другой массив (другой цикл)
	int j, max, A[] = { 6, 4, 76, 34, 56, 30, 44 }, n, k, i, B[sizeof(A) / sizeof(int)];
	int n1 = n = sizeof(A) / sizeof(int);
	//-
	for (j = 0, max = A[0]; j < n; j++)
		if (A[j] > max) max = A[j]; // поиск максимального элемента в массиве A; max - переменная-максимум
	for (j = 0; j < n; j++) {
		for (k = 0, i = 1; i < n; i++)
			if (A[i] < A[k]) k = i; // ищем наименьший элемент
		B[j] = A[k]; // записываем наименьший в массив B
		A[k] = max + 1; // перезаписываем только что найденный наименьший элемент максимальным + 1
	}
	//-
	for (i = 0; i < n1; i++)
		printf("%d ", B[i]); // получаем отсортированный массив
}

//--------------------------------------------------------46
void task_46() { // сортировка массива в порядке убывания
	int k, i, A[] = { 6, 4, 76, 34, 56, 30, 44 }, c;
	int n = sizeof(A) / sizeof(int);
	int n1 = n;
	//-
	while (n != 0) {
		for (k = 0, i = 1; i < n; i++)
			if (A[i] < A[k]) k = i; // находим наименьший; k - переменная-минимум
		c = A[k]; // записываем наименьший в c
		A[k] = A[n - 1]; // найденный наименьший перезаписываем последним элементом
		A[n - 1] = c; // наименьший записываем в последний
		n--; // уменьшаем кол-во проходов
	}
	//-
	for (i = 0; i < n1; i++)
		printf("%d ", A[i]); // получаем отсортированный массив в порядке убывания
}

//--------------------------------------------------------47
void task_47() { // числа, цифры которых делят это же число без остатка 
	int j, a, v, s, n, k, A[1000];
	printf("Введите число до которого будем смотреть:");
	scanf_s("%d", &v);
	//-
	for (j = 0, a = 10; a < v; a++) {
		for (s = 0, n = a, s = 0; n != 0; n = n / 10) { // перебираем цифры числа (отрезаем последнюю)
			k = n % 10; // берём последнюю цифру числа
			if (k != 0 && a % k != 0) { // пропускаем такие числа, у которых не 0 на конце и любая цифра числа делит само число с остатком
				s = 1; // s - переменная-признак
				break;
			}
		}
		if (s == 0) A[j++] = a;
	}
	//-
	printf("Числа, цифры которых делят это же число без остатка:\n");
	for (j = 0; A[j] >= 0; j++)
		printf("%d ", A[j]);
}

//--------------------------------------------------------48
void task_48() { // удаление цепочек из одинаковых элементов
	int i, A[] = { 1, 1, 67, 3, 78, 1, 5, 1, 1, 1, 1, 5, 5, 5, 5, 0 }, j;
	int n = sizeof(A) / sizeof(int);
	//-
	for (i = 0; i < n - 1; i++) // перебор массива
		if (A[i] == A[i + 1]) { // равность соседних элементов
			for (j = i; j < n - 2; j++) A[j] = A[j + 2]; // перезаписываем элемент через один
			n = n - 2; // удаляем элементы из массива
			i--; // снова проверяем цепочку на том же месте
		}
	//-
	for (i = 0; i < n; i++)
		printf("%d ", A[i]);
}

//--------------------------------------------------------49
void task_49() { // поиск наименьшего положительного числа в массиве
	int i, k, A[10] = { 4567, -2, 234, -2, 100, -14, -23, 120 ,34, -3 };
	//-
	for (i = 0, k = -1; i < 10; i++) {
		if (A[i] < 0) continue; // пропускаем отрицательные числа
		if (k == -1) k = i; // записываем любое первое попавшееся положительное число
		else
			if (A[i] < A[k]) k = i; // k - переменная-минимум
	}
	//-
	printf("Номер наименьшего положительного числа: %d", k);
}

//--------------------------------------------------------50
void task_50() { // поиск пар элементов, где первое число отрицательно, а второе положительное
	int i, s, k, A[10] = { 8, -2, 234, -2, 100, -14, -23, 1 ,34, -3 };
	//-
	for (i = 0, s = 0, k = 0; i < 10; i++)
		if (A[i] < 0) k = 1; // нашли отрицательное; k - переменная-признак
		else { // если нашли положительное
			if (k == 1) s++; // счёт пар; s - переменная-счётчик
			k = 0;
		}
	//-
	printf("Количество пар отрицательное-положительное: %d", s);
}

//--------------------------------------------------------51
void task_51() { // поиск самого большого числа в массиве (переменная-максимум)
	int i, s, A[10] = { 8, -2, -234, 2, 1040, -14, -23, 1 ,34, -3 };
	//-
	for (i = 0, s = 0; i < 10; i++)
		if (A[i] > s) s = A[i]; // поиск максимального элемента; s - переменная-максимум
	//-
	printf("Наибольшее число в массиве: %d", s);
}

//--------------------------------------------------------52
void task_52() { // поиск самого большого числа в массиве (поиск элемента)
	int i, k, A[10] = { 8, -2, -234, 2, 12140, -14, -23, 1, 34, 345 };
	//-
	for (i = 1, k = 0; i < 10; i++)
		if (A[i] > A[k]) k = i; // поиск максимального элемента; k - хранит в себе номер элемента
	//-
	printf("Номер наибольшего числа: %d", k);
}

//--------------------------------------------------------53
void task_53() { // поиск номера наименьшего положительного числа в массиве №1
	int i, k, A[10] = { 8, -2, -234, 2, 10, -14, -23, 1 ,34 ,67 };
	//-
	for (i = 0, k = -1; i < 10; i++)
	{
		if (A[i] < 0) continue; // пропускаем отрицательное число
		if (k == -1) k = i; // нашли первое положительное - записываем его номер
		else // если нашли уже не первое положительное, то
			if (A[i] < A[k]) k = i; // если оно меньше предыдущего найденного, то записываем его номер 
	}
	//-
	printf("Номер наименьшего положительного числа: %d", k);
}

//--------------------------------------------------------54
void task_54() { // поиск номера наименьшего положительного числа в массиве №2 (через ||)
	int i, k, A[10] = { 8, -2, -234, 2, 10, -14, -23, 5 ,34 ,67 };
	//-
	for (i = 0, k = -1; i < 10; i++)
	{
		if (A[i] < 0) continue; // пропускаем отрицательные числа 
		if (k == -1 || A[i] < A[k]) k = i; // нашли первое положительное - записываем его номер; если оно меньше предыдущего найденного, то записываем его номер 
	}
	//-
	printf("Номер наименьшего положительного числа: %d", k);
}

//--------------------------------------------------------55
void task_55() { // счёт колличества положительных чисел
	int i, s, A[10] = { 10, 2, 4, 6, -7, -8, 5, 20, -45, 23 };
	//-
	for (i = 0, s = 0; i < 10; i++)
		if (A[i] > 0) s++; // s - переменная-счётчик
	//-
	printf("Количество положительных чисел: %d", s);
}

//--------------------------------------------------------56
void task_56() { // поиск пар отрицательное-положительное в массиве
	int i, s, A[10] = { 10, -2, 4, -6, 5, -7, 45, 8, 1, 234 };
	//-
	for (i = 1, s = 0; i < 10; i++)
		if (A[i] > 0 && A[i - 1] < 0) s++; // если число слева отрицательное, а справа - положительное, то s++; s - переменная-счётчик
	//-
	printf("Количество пар отрицательное-положительное в массиве: %d", s);
}

//--------------------------------------------------------57
void task_57() { // поиск самой длинной возрастающей цепочки
	int i, s, k, A[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
	//-
	for (i = 1, s = 0, k = 0; i < 10; i++) {
		if (A[i - 1] < A[i]) k++; // если число слева меньше числа справа от него, то k++; k - переменная-счётчик
		else { // иначе
			if (k > s) s = k; // записываем самую длинную возрастающую цепочку 
			k = 0;
		}
	}
	//-
	printf("Наидлинейшая возрастающая цепочка: %d", s);
}

//--------------------------------------------------------58
void task_58() { // АБСОЛЮТНО ТОЖЕ ЗАДАНИЕ, ЧТО И №50
	int i, s, k, A[10] = { -10, -2 ,-4, -6, 12, 5, 8, 2, -1, 20 };
	//-
	for (i = 0, s = 0, k = 0; i < 10; i++)
		if (A[i] < 0) k = 1; // если элемент отрицателен, то ; k - переменная-признак
		else          // программа выводит колличество соседствующих цифр, где 1 чило отрицательно, а второе положительное
		{
			if (k == 1) s++; // s - переменная-счётчик
			k = 0;
		}
	//-
	printf("Количество пар отрицательное-положительное: %d", s);
}