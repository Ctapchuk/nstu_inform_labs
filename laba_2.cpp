#include <iostream>
#include <locale.h>
#include <stdio.h>
#define  _CRT_SECURE_NO_WARNINGS
using namespace std;

// Прототипы функций
int task_14(int&); // наибольшая цифра числа
int task_15(int*); // переворот числа

void task_20(int[], int&); // удаление максимального элемента из массива
void task_21(int); // поиск простых чисел №1 
void task_22(int[], int, int); // поиск простых чисел №2 (цикл с переменной-защёлкой)
void task_23(int[], int, int[]); // поиск простых чисел №3 (поиск по массиву, запись найденных в другой массив)

void task_32(int[], int, int&, int&); // поиск повторяющихся элементов в массиве, считаем их и выводим самое часто встречающееся число с его кол-вом повторов

void task_44(int[], int, int[]); // сортировка чисел в порядке возрастания и запись их в другой массив

int task_57(int*); // поиск самой длинной возрастающей цепочки
int task_58(int*); // АБСОЛЮТНО ТОЖЕ ЗАДАНИЕ, ЧТО И №50

int main() // Запускать здесь 
{
	setlocale(LC_ALL, "Rus"); // кодировка с поддержкой кириллицы

	// Рандомные значения

	int i;
	int g1 = 12;
	int g2 = 153;
	int g3 = 5670;

	int A1[] = { 1, 2343, 544, 6, -53245, 43, 213 };
	int An1 = size(A1);

	int A2[] = { -1235, -645, 0, -456, 98, -123, 13 };
	int An2 = size(A2);

	int A3[] = {0, -23, 75, -1234, 45, -456, 264 };
	int An3 = size(A3);

	int A4[] = { 97, -53, 234, 634, -2, 9, -34, 543, -3, 5 };
	int An4 = size(A4);

	// передача ссылки; ссылка есть ссылка, её адрес никогда не меняется
	cout << "--Debug: main: значение адреса:    " << &g1 << endl;
	printf("F14-1-%d\n", task_14(g1));
	cout << "--Debug: main: значение адреса:    " << &g2 << endl;
	printf("F14-2-%d\n", task_14(g2));
	cout << "--Debug: main: значение адреса:    " << &g3 << endl;
	printf("F14-3-%d\n\n", task_14(g3));

	// передача указателя; указатель имеет собственный адрес, в котором хранится адрес на оригинальную переменную; в функции создаётся указатель на указатель
	int *pg = &g1;
	cout << "--Debug: main: значение адреса:    " << &pg << endl;
	printf("F15-1-%d\n", task_15(pg)); // отправляем адрес переменной и при входе в функцию адрес записывается в указатель
	pg = &g2;
	cout << "--Debug: main: значение адреса:    " << &pg << endl;
	printf("F15-2-%d\n", task_15(pg));
	pg = &g3;
	cout << "--Debug: main: значение адреса:    " << &pg << endl;
	printf("F15-3-%d\n\n", task_15(pg));

	// название массива - есть указатель на первый элемент массива, т.е. массив всегда передаётся по указателю
	task_20(A1, An1);
	printf("F20-1-( ");
	for (i = 0; i < An1; i++) {
		printf("%d ", A1[i]);
	}
	printf(")\n");

	task_20(A2, An2);
	printf("F20-2-( ");
	for (i = 0; i < An2; i++) {
		printf("%d ", A2[i]);
	}
	printf(")\n");

	task_20(A3, An3);
	printf("F20-3-( ");
	for (i = 0; i < An3; i++) {
		printf("%d ", A3[i]);
	}
	printf(")\n\n");

	// передача значения
	g1 = 19;
	printf("F21-1-( ");
	task_21(g1);
	printf(")\n");

	g2 = 78;
	printf("F21-2-( ");
	task_21(g2);
	printf(")\n");

	g3 = 53;
	printf("F21-3-( ");
	task_21(g3);
	printf(")\n\n");


	// передача массива, его размер и другое число
	printf("F22-1-( ");
	int B[10000];
	task_22(B, size(B), g1);
	for (i = 0; B[i] != 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n");

	printf("F22-2-( ");
	task_22(B, size(B), g2);
	for (i = 0; B[i] != 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n");

	printf("F22-3-( ");
	task_22(B, size(B), g3);
	for (i = 0; B[i] != 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n\n");

	//

	int C1[] = { 1, 2343, 544, 6, -53245, 43, 213 };
	int Cn1 = size(C1);

	int C2[] = { 2, -645, 0, 5, 98, 97, 13 };
	int Cn2 = size(C2);

	int C3[] = { 3, -23, 63, 87, 5, 59, 103 };
	int Cn3 = size(C3);

	int C4[] = { 97, -53, 234, 13, -2, 9, 53, 543, -3, 5 };
	int Cn4 = size(C4);

	// передача двух массивов с помощью указателя и переменной по значению
	printf("F23-1-( ");
	task_23(C4, Cn4, B);
	for (i = 0; B[i] != 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n");

	printf("F23-2-( ");
	task_23(C3, Cn3, B);
	for (i = 0; B[i] > 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n");

	printf("F23-3-( ");
	task_23(C2, Cn2, B);
	for (i = 0; B[i] != 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n\n");

	// 

	int D1[] = { 6, -53, 4, 13, 6, 6, 6, 5, 4, 5 };
	int Dn1 = size(D1);

	int D2[] = { 70, 4567, 4, 70, 70, 70, 70, 4, 4, 5 };
	int Dn2 = size(D2);

	int D3[] = { 67, -53, 4, 13, 56, 7, 6, 45, 45, 5 };
	int Dn3 = size(D3);

	int Dx = 0;
	int Dxs = 0;

	// передача массива с помощью указателя, его размера и ещё двух переменных по ссылке

	task_32(D1, Dn1, Dx, Dxs);
	printf("F32-1-( %d %d )\n", D1[Dx], Dxs);

	task_32(D2, Dn2, Dx, Dxs);
	printf("F32-2-( %d %d )\n", D2[Dx], Dxs);

	task_32(D3, Dn3, Dx, Dxs);
	printf("F32-3-( %d %d )\n\n", D3[Dx], Dxs);

	// передача массива по указателю и его размер; передача второго массива чтобы в него записали первый отсортированный

	printf("F44-1-( ");
	task_44(C1, Cn1, B);
	for (i = 0; i != Cn1; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n");

	printf("F44-2-( ");
	task_44(C2, Cn2, B);
	for (i = 0; i != Cn2; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n");

	printf("F44-3-( ");
	task_44(C4, Cn4, B);
	for (i = 0; i != Cn4; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n\n");

	//

	int F1[] = { 1, 2343, 544, 6, -53245, 43, 213 };
	int Fn1 = size(F1);

	int F2[] = { 2, -645, 0, -5, 98, 97, 13 };
	int Fn2 = size(F2);

	int F3[] = { 3, -23, 63, 87, 5, 59, 103 };
	int Fn3 = size(F3);

	int F4[] = { 97, -53, 234, 13, -2, 9, 53, 543, -3, 5 };
	int Fn4 = size(F4);

	// передача массива под видом указателя; функция переделана под арифметику указателя
	printf("F57-1-%d\n", task_57(F1));
	printf("F57-2-%d\n", task_57(F2));
	printf("F57-3-%d\n\n", task_57(F3));

	printf("F58-1-%d\n", task_58(F4));
	printf("F58-2-%d\n", task_58(F2));
	printf("F58-3-%d\n", task_58(F3));
}

//--------------------------------------------------------14
int task_14(int& a) { // наибольшая цифра числа
	int n, s, k;
	a = abs(a); // Модуль числа, избавляемся от минуса
	//-
	for (n = a, s = 0; n != 0; n = n / 10) // перебор каждой цифры в числе a
	{
		k = n % 10; // берём цифру с конца числа n
		if (k > s) s = k; // s присваивается наибольшая цифра числа; переменная-максимум
	}
	//-
	cout << "--Debug: task_14: значение адреса: " << &a << endl;
	return s;
}

//--------------------------------------------------------15
int task_15(int *a) { // переворот числа
	int n, s, k;
	//-
	for (n = *a, s = 0; n != 0; n = n / 10) // перебор каждой цифры в числе a
	{
		k = n % 10; // берём цифру с конца числа n
		s = s * 10 + k; // в первый раз берём k для s потом приписываем 0 к s (сдвиг влево) и снова добавляем k; в конце получаем число наоборот; переменная-накопитель
	}
	//-
	cout << "--Debug: task_15: значение адреса: " << &a << endl;
	return s;
}

//--------------------------------------------------------20
void task_20(int A[], int& n) { // удаление максимального элемента из массива
	int i, k, j;
	//-
	for (i = 1, k = 0; i < n; i++)
		if (A[i] > A[k]) k = i; // находим номер максимального элемента в массиве; k - переменная-максимум
	for (j = k; j < n - 1; j++) A[j] = A[j + 1]; // сдвигаем массив влево перезаписывая при этом максимальный элемент в массиве
	n--; // кол-во элементов в массиве теперь на 1 меньше
	//-
}

//--------------------------------------------------------21
void task_21(int v) { // поиск простых чисел №1
	int i, a, n, A[10000]; // ситуация таже, заранее неизвестно какой размер массива требуется, берём с запасом
	//-
	for (i = 0, a = 2; a < v; a++) { // простые числа начинаются с 2, a - число
		for (n = 2; n < a; n++) // проверяем в цикле от 2 до самого числа его делители, n - играет роль делителя числа
		{
			if (a % n == 0) break; // остаток от деления 0 означает, что существует делитель n для а
		}
		if (n == a) A[i++] = a; // если число равно делителю, то значит брейк на предыдущем шаге произошёл при делении числа самого на себя, следовательно до этого момента ни одного делителя для этого числа не было найдено и значит это число простое
	}
	A[i] = 0; // конец массива
	//-
	for (i = 0; A[i] > 0; i++) // выводим массив; все простые числа - натуральные (> 0)
		printf("%d ", A[i]);
}

//--------------------------------------------------------22
void task_22(int A[], int n, int v) { // поиск простых чисел №2 (цикл с переменной-защёлкой)
	int i, a, s; // ситуация таже, заранее неизвестно какой размер массива требуется, берём с запасом
	//-
	for (i = 0, a = 2; a < v; a++) { // простые числа начинаются с 2, a - число
		for (s = 0, n = 2; n < a; n++) // проверяем в цикле от 2 до самого числа его делители, n - играет роль делителя числа, s - переменная-проверка наличия делителя
			if (a % n == 0) {
				s = 1; // есть делитель, брейкаемся; s - переменная-признак
				break;
			}
		if (s == 0) A[i++] = a; // s = 0 значит делителя нет, число простое
	}
	A[i] = 0;
	//-
}

//--------------------------------------------------------23
void task_23(int A[], int n, int B[]) { // поиск простых чисел №3 (поиск по массиву, запись найденных в другой массив)
	int j, i, m;	
	//-
	for (j = 0, i = 0; i < n; i++) { // перебираем элементы массива
		for (m = 2; m < A[i]; m++) // перебираем делители m от 2 до числа A[i] не включительно
		{
			if (A[i] % m == 0) break; // нашли делитель, число непростое, брейк
		}
		if (m == A[i]) B[j++] = A[i]; // нашли простое число, добавляем его в массив B
	}
	B[j] = 0;
	//-
}

//--------------------------------------------------------32
void task_32(int c[], int n, int& b, int& s) { // поиск повторяющихся элементов в массиве, считаем их и выводим самое часто встречающееся число с его кол-вом повторов
	int i, k, j;
	//-
	for (s = 0, i = 0; i < n; i++) { // первый цикл по элементам
		for (k = 0, j = 0; j < n; j++) // второй цикл по элементам
			if (c[i] == c[j]) k++; // если какие-то элементы будут равны (проверяем даже одинаковые элементы чтобы указать что существует одно число); k - переменная-счётчик
		if (k > s) s = k, b = i; // находим максимальное кол-во повторившихся ( (k > s) s = k ) и записывание номер этого элемента ( b = i ), получаем пару номер элемента и его повторений в массиве; s - переменная-максимум
	}
	//-
}

//--------------------------------------------------------44
void task_44(int A[], int n, int B[]) { // сортировка чисел в порядке возрастания и запись их в другой массив
	int j, k, i;
	int n1 = n;
	//-
	for (j = 0; n != 0; j++) {
		for (k = 0, i = 1; i < n; i++)
			if (A[i] < A[k]) k = i; // наименьший элемент в массиве A
		B[j] = A[k]; // записываем наименьший в B
		for (; k < n - 1; k++) A[k] = A[k + 1]; // затираем наименьший элемент со сдвигом влево
		n--; // массив был уменьшен через сдвиг, так что уменьшаем кол-во элементов
	}
	//-
}

//--------------------------------------------------------57
int task_57(int* A) { // поиск самой длинной возрастающей цепочки
	int i, s, k;
	//-
	for (i = 1, s = 0, k = 0; i < 10; i++) {
		if (*(A + i - 1) < *(A + i)) k++; // если число слева меньше числа справа от него, то k++; k - переменная-счётчик
		else { // иначе
			if (k > s) s = k; // записываем самую длинную возрастающую цепочку 
			k = 0;
		}
	}
	//-
	return s;
}

//--------------------------------------------------------58
int task_58(int* A) { // АБСОЛЮТНО ТОЖЕ ЗАДАНИЕ, ЧТО И №50
	int i, s, k;
	//-
	for (i = 0, s = 0, k = 0; i < 10; i++)
		if (*(A + i) < 0) k = 1; // если элемент отрицателен, то ; k - переменная-признак
		else          // программа выводит колличество соседствующих цифр, где 1 чило отрицательно, а второе положительное
		{
			if (k == 1) s++; // s - переменная-счётчик
			k = 0;
		}
	//-
	return s;
}