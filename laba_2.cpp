#include <iostream>
#include <locale.h>
#include <stdio.h>
#define  _CRT_SECURE_NO_WARNINGS

// Прототипы функций
int task_13(int); // сумма цифр числа
int task_14(int&); // наибольшая цифра числа
int task_15(int*); // переворот числа

void task_20(int(&)[7], int&); // удаление максимального элемента из массива
void task_21(int); // поиск простых чисел №1 
void task_22(int*, int, int); // поиск простых чисел №2 (цикл с переменной-защёлкой)
void task_23(int*, int, int*); // поиск простых чисел №3 (поиск по массиву, запись найденных в другой массив)

int task_56(int*); // поиск пар отрицательное-положительное в массиве
int task_57(int*); // поиск самой длинной возрастающей цепочки
int task_58(int(&)[7]); // АБСОЛЮТНО ТОЖЕ ЗАДАНИЕ, ЧТО И №50

int main() // Запускать здесь 
{
	setlocale(LC_ALL, "Rus"); // кодировка с поддержкой кириллицы

	int i;
	int g1 = 12;
	int g2 = 153;
	int g3 = 5670;

	int A1[] = { 1, 2343, 544, 6, -53245, 43, 213 };
	int An1 = sizeof(A1) / sizeof(int);

	int A2[] = { -1235, -645, 0, -456, 98, -123, 13 };
	int An2 = sizeof(A2) / sizeof(int);

	int A3[] = {0, -23, 75, -1234, 45, -456, 264 };
	int An3 = sizeof(A3) / sizeof(int);

	int A4[] = { 97, -53, 234, 634, -2, 9, -34, 543, -3, 5 };
	int An4 = sizeof(A3) / sizeof(int);

	//int *h = A; // объявление указателя
	//h = &A; // задаём адресс указателю

	// передача значения
	printf("F13-1-%d\n", task_13(g1)); 
	printf("F13-2-%d\n", task_13(g2));
	printf("F13-3-%d\n\n", task_13(g3));

	// передача ссылки
	printf("F14-1-%d\n", task_14(g1));
	printf("F14-2-%d\n", task_14(g2));
	printf("F14-3-%d\n\n", task_14(g3));

	//передача указателя
	int* p1;
	p1 = &g1;
	int* p2;
	p2 = &g2;
	int* p3;
	p3 = &g3;
	printf("F15-1-%d\n", task_15(p1));
	printf("F15-2-%d\n", task_15(p2));
	printf("F15-3-%d\n\n", task_15(p3));

	// передача ссылки на массив и ссылки на его размер
	task_20(A1, An1);
	printf("F20-1-( ");
	for (i = 0; i < An1; i++) {
		printf("%d ", A1[i]);
	}
	printf(")\n");

	task_20(A2, An2);
	printf("F20-2-( ");
	for (i = 0; i < An2; i++) {
		printf("%d ", A2[i]);
	}
	printf(")\n");

	task_20(A3, An3);
	printf("F20-3-( ");
	for (i = 0; i < An3; i++) {
		printf("%d ", A3[i]);
	}
	printf(")\n\n");

	// передача значения
	g1 = 19;
	printf("F21-1-( ");
	task_21(g1);
	printf(")\n");

	g2 = 78;
	printf("F21-2-( ");
	task_21(g2);
	printf(")\n");

	g3 = 53;
	printf("F21-3-( ");
	task_21(g3);
	printf(")\n\n");


	// передача массива по указателю и переменной по значению
	printf("F22-1-( ");
	int B[10000];
	task_22(B, 10000, g1);
	for (i = 0; B[i] > 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n");

	printf("F22-2-( ");
	task_22(B, 10000, g2);
	for (i = 0; B[i] > 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n");

	printf("F22-3-( ");
	task_22(B, 10000, g3);
	for (i = 0; B[i] > 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n\n");

	// передача двух массивов с помощью указателя и переменной по значению
	printf("F23-1-( ");
	task_23(A4, An4, B);
	for (i = 0; B[i] > 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n");

	printf("F23-2-( ");
	task_23(A1, An1, B);
	for (i = 0; B[i] > 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n");

	printf("F23-3-( ");
	task_23(A2, An2, B);
	for (i = 0; B[i] > 0; i++) {
		printf("%d ", B[i]);
	}
	printf(")\n\n");

	// передача массива с помощью указателя
	printf("F56-1-%d\n", task_56(A1));
	printf("F56-2-%d\n", task_56(A2));
	printf("F56-3-%d\n\n", task_56(A3));

	printf("F57-1-%d\n", task_57(A1));
	printf("F57-2-%d\n", task_57(A2));
	printf("F57-3-%d\n\n", task_57(A3));

	// передача массива с помощью ссылки
	printf("F58-1-%d\n", task_58(A1));
	printf("F58-2-%d\n", task_58(A2));
	printf("F58-3-%d\n", task_58(A3));
}

//--------------------------------------------------------13
int task_13(int a) { // сумма цифр числа
	int n, s, k;
	a = abs(a); // Модуль числа, избавляемся от минуса
	//-
	for (n = a, s = 0; n != 0; n = n / 10) // перебор каждой цифры в числе a
	{
		k = n % 10; // берём цифру с конца числа n
		s = s + k;  // s - сумма всех цифр числа; переменная-накопитель
	}
	//-
	return s;
}

//--------------------------------------------------------14
int task_14(int& a) { // наибольшая цифра числа
	int n, s, k;
	a = abs(a); // Модуль числа, избавляемся от минуса
	//-
	for (n = a, s = 0; n != 0; n = n / 10) // перебор каждой цифры в числе a
	{
		k = n % 10; // берём цифру с конца числа n
		if (k > s) s = k; // s присваивается наибольшая цифра числа; переменная-максимум
	}
	//-
	return s;
}

//--------------------------------------------------------15
int task_15(int *a) { // переворот числа
	int n, s, k;
	//-
	for (n = *a, s = 0; n != 0; n = n / 10) // перебор каждой цифры в числе a
	{
		k = n % 10; // берём цифру с конца числа n
		s = s * 10 + k; // в первый раз берём k для s потом приписываем 0 к s (сдвиг влево) и снова добавляем k; в конце получаем число наоборот; переменная-накопитель
	}
	//-
	return s;
}

//--------------------------------------------------------20
void task_20(int (&A)[7], int& n) { // удаление максимального элемента из массива
	int i, k, j;
	//-
	for (i = 1, k = 0; i < n; i++)
		if (A[i] > A[k]) k = i; // находим номер максимального элемента в массиве; k - переменная-максимум
	for (j = k; j < n - 1; j++) A[j] = A[j + 1]; // сдвигаем массив влево перезаписывая при этом максимальный элемент в массиве
	n--; // кол-во элементов в массиве теперь на 1 меньше
	//-
}

//--------------------------------------------------------21
void task_21(int v) { // поиск простых чисел №1
	int i, a, n, A[10000]; // ситуация таже, заранее неизвестно какой размер массива требуется, берём с запасом
	//-
	for (i = 0, a = 2; a < v; a++) { // простые числа начинаются с 2, a - число
		for (n = 2; n < a; n++) // проверяем в цикле от 2 до самого числа его делители, n - играет роль делителя числа
		{
			if (a % n == 0) break; // остаток от деления 0 означает, что существует делитель n для а
		}
		if (n == a) A[i++] = a; // если число равно делителю, то значит брейк на предыдущем шаге произошёл при делении числа самого на себя, следовательно до этого момента ни одного делителя для этого числа не было найдено и значит это число простое
	}
	A[i] = 0; // конец массива
	//-
	for (i = 0; A[i] > 0; i++) // выводим массив; все простые числа - натуральные (> 0)
		printf("%d ", A[i]);
}

//--------------------------------------------------------22
void task_22(int* A, int n, int v) { // поиск простых чисел №2 (цикл с переменной-защёлкой)
	int i, a, s; // ситуация таже, заранее неизвестно какой размер массива требуется, берём с запасом
	//-
	for (i = 0, a = 2; a < v; a++) { // простые числа начинаются с 2, a - число
		for (s = 0, n = 2; n < a; n++) // проверяем в цикле от 2 до самого числа его делители, n - играет роль делителя числа, s - переменная-проверка наличия делителя
			if (a % n == 0) {
				s = 1; // есть делитель, брейкаемся; s - переменная-защёлка
				break;
			}
		if (s == 0) A[i++] = a; // s = 0 значит делителя нет, число простое
	}
	A[i] = 0;
	//-
}

//--------------------------------------------------------23
void task_23(int* A, int n, int* B ) { // поиск простых чисел №3 (поиск по массиву, запись найденных в другой массив)
	int j, i, m;	
	//-
	for (j = 0, i = 0; i < n; i++) { // перебираем элементы массива
		for (m = 2; m < A[i]; m++) // перебираем делители m от 2 до числа A[i] не включительно
		{
			if (A[i] % m == 0) break; // нашли делитель, число непростое, брейк
		}
		if (m == A[i]) B[j++] = A[i]; // нашли простое число, добавляем его в массив B
	}
	B[j] = 0;
	//-
}

//--------------------------------------------------------56
int task_56(int* A) { // поиск пар отрицательное-положительное в массиве
	int i, s;
	//-
	for (i = 1, s = 0; i < 10; i++)
		if (A[i] > 0 && A[i - 1] < 0) s++; // если число слева отрицательное, а справа - положительное, то s++; s - переменная-счётчик
	//-
	return s;
}

//--------------------------------------------------------57
int task_57(int* A) { // поиск самой длинной возрастающей цепочки
	int i, s, k;
	//-
	for (i = 1, s = 0, k = 0; i < 10; i++) {
		if (A[i - 1] < A[i]) k++; // если число слева меньше числа справа от него, то k++; k - переменная-счётчик
		else { // иначе
			if (k > s) s = k; // записываем самую длинную возрастающую цепочку 
			k = 0;
		}
	}
	//-
	return s;
}

//--------------------------------------------------------58
int task_58(int (&A)[7]) { // АБСОЛЮТНО ТОЖЕ ЗАДАНИЕ, ЧТО И №50
	int i, s, k;
	//-
	for (i = 0, s = 0, k = 0; i < 10; i++)
		if (A[i] < 0) k = 1; // если элемент отрицателен, то ; k - переменная-защёлка
		else          // программа выводит колличество соседствующих цифр, где 1 чило отрицательно, а второе положительное
		{
			if (k == 1) s++; // s - переменная-счётчик
			k = 0;
		}
	//-
	return s;
}